#!/usr/bin/env perl 

use strict;
use warnings;

use Data::Dumper;

use Cwd qw/abs_path cwd getcwd/;
use File::Basename;
use File::Path qw/make_path/;
use IPC::Open3;
use IO::Select;
use Getopt::Long qw/:config pass_through/;
use Module::ScanDeps;
use Sys::Hostname;
use Symbol 'gensym';

$| = 1;

my $context = {
    work_cmd        => abs_path( $0 ),
    cwd             => getcwd,
    cmd             => $0,
    name            => 'rperl',
    remote          => undef,
    args            => [ @ARGV ],
    debug           => 0,
    perl            => "perl",
    dependencies    => [],
    localhost       => hostname(),
    action          => "rperl",
};

my %actions = (
    rperl           => \&rperl,
    config          => \&dump_context,
    reproduce       => \&reproduce,
    host            => \&host,
    remote_dir      => \&set_remote_dir,
    dep             => \&list_dependencies,
    alldep          => \&list_all_dependencies,
    changed         => \&modified,
    remote          => \&remote,
    slurp           => \&slurp_dependencies,
);

my @run_actions;

GetOptions(
    "file=s"        => \$context->{ file },
    "config"        => sub { push @run_actions, "config" },
    "host=s"        => sub { 
                            push @run_actions, "host"; 
                            $context->{ remote } = $_[1] 
                       },
    "remote_dir:s"    => sub { 
                            push @run_actions,"remote_dir"; 
                            $context->{ remote_dir } = $_[1]
                       },
    "dep"           => sub { push @run_actions, "dep" },
    "alldep"        => sub { push @run_actions, "alldep" },
    "changed"       => sub { push @run_actions, "changed" },
    "remote"        => sub { push @run_actions, "remote" },
    "slurp"         => sub { push @run_actions, "slurp" },
    "run"           => sub { push @run_actions, "rperl" },
    '<>'            => \&_parameters,
);

push @run_actions, "rperl" if !@run_actions;

if ( $ENV{ DEBUG_RPERL } ) {
    print "Actions: ", map { "$_\n" } @run_actions;
}

for my $action ( @run_actions ) {
    $actions{ $action }();
}

sub _parameters {
    push @{ $context->{ remote_args } }, $_[0];
}

sub dump_context {   
    prepare_to_run();
    print Dumper $context;
}


sub reproduce {
    $context->{ file } = $context->{ work_cmd };
    # add something to run
    # host name + rperl  + perl version
    @{ $context->{ args } } = ( qw/ -v / );
    rperl();
}

sub host {
    remote_host( $context->{ remote } );
    print "Actual host: $context->{ remote }\n";
}

sub set_remote_dir{
    remote_host();

    if ( ! defined $context->{ remote_dir } ){
        unlink "$ENV{ HOME }/.rperl_remote_dir";
    } else {
        my @cmd = (
            'ssh', $context->{ remote } , 'cd' , $context->{ remote_dir },
        );
        my ( $status, $s,$e ) = _command( @cmd );
        if ( $status ) {
            die "[$status] Remote directory $context->{ remote_dir } does not exists\n";
        }

        open my $fh, ">", "$ENV{HOME}/.rperl_remote_dir" or die;
            print $fh $context->{ remote_dir };
        close $fh;
    }

    undef $context->{ remote_dir };
    _remote_dir();
    print "Actual remote directory is " . ( 
            $context->{ remote_dir } ? 
            "$context->{ remote_dir }\n" :
            "not set\n"
          );
}

sub remote {
    $context->{ file } = $context->{ work_cmd };
    unshift @{ $context->{ args } }, $context->{ file };

    prepare_to_run();
    #rsync();  ( just for rperl, should be done by reproduce
    my @result = run_remote();

    print "\t$_" for @result;
    
}

sub slurp_dependencies {
    $context->{ file } = $context->{ work_cmd };
    unshift @{ $context->{ args } }, $context->{ file }, ":dep";

    prepare_to_run();

    my @result = run_remote();

    my @cmds;

    for my $result ( @result ) {
        chomp $result;
        push @cmds, $result if $result;
    }

    for my $file ( @cmds ) {
        my @cmd = ( "rsync", "$context->{ remote }:$file", $file );
        print "Slurping $file from $context->{ remote }...";
        make_path dirname $file;  
        if( ! run_local( @cmd ) ) {
            print "with success\n";
        }else{
            print " but it failed.. $?\n";
        }
    }
    
}

sub input_file {
    warn Dumper $context;
    if ( @{ $context->{ remote_args } } ) {
        if ( -e $context->{ remote_args }[0] ) {
            ( $context->{ file } ) = shift @{ $context->{ remote_args } };
        }
    }
    warn Dumper $context;
    if ( ! $context->{ file } || ! -e $context->{ file } ) {
        die "One of the parameters must be a valid perl script\n";
    }
   
    $context->{ file_abs_path } = abs_path( $context->{ file } ); 
    if ( -d $context->{ file_abs_path } ) {
        $context->{ dir_abs_path } = $context->{ file_abs_path };
    }else{
        $context->{ dir_abs_path } = dirname( abs_path( $context->{ file } ));
    }
}

sub git_top_level{ 

    # closure
    chdir $context->{ dir_abs_path };
    $context->{ git_tree } = `git rev-parse --show-toplevel 2>/dev/null`;
    chomp $context->{ git_tree };

    # or we have a .fperl_git file
    if ( ! $? ) {
        while ( cwd() ne '/' ) {
            if ( -e ".fperl_git" ) {
                $context->{ git_tree } = cwd();
            }
            chdir( ".." );
        }
    }else{
        warn "There is not .fperl_git file\n" if ! -e  "$context->{ git_tree }/.fperl_git";
    }

    if ( $context->{ remote_dir } ) {
        $context->{ run_path } = 
            $context->{ remote_dir } . 
            substr( 
                $context->{ cwd },
                length( dirname( $context->{ git_tree } )),
            );
    } else {
        $context->{ run_path } = $context->{ cwd };
    }

    chdir $context->{ cwd };

    die "The command $context->{ file } is not on a git_tree\n"
        if ! $context->{ git_tree };
}

sub modified {
    input_file();
    git_top_level();
    git_modified_files();
    # TODO just dependencies
    print join "\n", @{ $context->{ modified } }, "\n";
}

sub git_modified_files {
    chdir $context->{ git_tree };
    @{ $context->{ modified } } = `git ls-files -m`;
    chdir $context->{ cwd };
}

# required
sub dependencies {
    input_file();

    git_top_level();

    chdir "$context->{ git_tree }/lib";

    my $what = scan_deps( files => [ $context->{ file_abs_path } ] , recurse => 0 );

    for my $module ( keys %$what ) {
        next if $module eq $context->{ file };
        if ( -e $module ) {
            push @{ $context->{ dependencies } }, $module;
        }
        push @{ $context->{ all_dependencies } }, $module;
    }
}

sub list_dependencies {
    dependencies();
    if ( @{ $context->{ dependencies } } ) {
        print "$context->{ file_abs_path }\n";
        print join "\n", ( map { "$context->{ git_tree }/lib/$_" } @{ $context->{ dependencies } } ) , "\n";
    }else{
        print "No local dependencies found for this module\n";
    }
}

sub list_all_dependencies {
    dependencies();
    if ( @{ $context->{ all_dependencies } } ) {
        print "$context->{ file_abs_path }\n";
        print join "\n", @{ $context->{ all_dependencies } }, "\n";
    }else{
        print "No local dependencies found for this module\n";
    }
}

sub remote_host {
    my $host = shift;
    
    if ( $host ) {
        my $run = `ssh $host exit`;  # TODO : exists_ssh_host
        
        if ( $? ){
            die <<EOF;
        The host: $host is offline or not configured on 
        ssh config file. Please check your ssh config on 
        $ENV{HOME}/.ssh/config.
EOF
        }else{
            open my $fh , ">", "$ENV{HOME}/.rperl_remote" or die;
                print $fh "$host";
            close $fh;
        }
    }
    
    #eval
    open my $fh, "<", "$ENV{HOME}/.rperl_remote" or die;
        $context->{ remote } = <$fh>;
    close $fh;
}

sub _remote_dir {
    return if ! -e "$ENV{HOME}/.rperl_remote_dir";
    open my $fh, "<",  "$ENV{HOME}/.rperl_remote_dir" or die;
        $context->{ remote_dir } = <$fh>;
    close $fh;
}

sub rsync {

    # check requirements
    my $remote_dir = $context->{ remote_dir } ? $context->{ remote_dir } : dirname( $context->{ git_tree } );

    # For the first time sync, after followup the changed files
    print "Prepare for: $context->{ file } from $context->{ cwd } @ $context->{ remote } on $remote_dir\n" if $ENV{ DEBUG_RPERL };
    
    my $r_mkdir = `ssh $context->{ remote } mkdir -p $remote_dir`;
    
    my $sync_cmd = "rsync --exclude=.git --cvs-exclude -a $context->{ git_tree } $context->{ remote }:$remote_dir --delete";
    warn "$sync_cmd \n" if $ENV{ DEBUG_RPERL };
    my $sync = qx/$sync_cmd/;
    if ( $? ) {
        die "$?\nError when syncing $context->{ remote }:$context->{ git_tree }\n";
    }else{
        print "Syncronized to: $context->{ remote }:$remote_dir\n";
    }
}

sub prepare_to_run {
    input_file();
    remote_host();
    _remote_dir();
    git_top_level();  
    die "There is no remote configured, please run rperl_host!\n" 
        if ! $context->{ remote };
}

sub rperl {
  
    prepare_to_run();

    rsync();

    $context->{ io_sync } = 1;

    my @cmd = (
        'ssh', $context->{ remote }, 
        'echo -n "Remote Shell PID:";',
        'export RPERL_PID=$$;', 
        'echo $RPERL_PID;',
        "export PERL5LIB=$context->{ run_path }/lib:\$PERL5LIB ;", 
        'cd', $context->{ run_path }, ';',
        $context->{ perl }, @{ $context->{ args } }, ';', 
        'pgrep -P $RPERL_PID;',
        'echo',
        );

    if ( $ENV{ DEBUG_RPERL } ) {
        warn Dumper \@cmd; 
        print join " ", @cmd, "\n";
    }
    
    my ( $status, $stdout, $stderr ) = _command( @cmd );
    if ( $status ) {
        print "Error $status when running $context->{ file }\n";
        print join " ", @cmd, "\n";
    }
}

sub _command {
    my ( @cmd ) = @_;

    my ( $wtr, $rdr, $err, $pid );
    $err = gensym();

    eval {
        $pid = open3( $wtr, $rdr, $err, @cmd );
    };
    die "$@\n" if $@;

    my $sel = IO::Select->new;
    $sel->add( $rdr, $err );

    my ( $stdout, $stderr );

    while ( my @ready = $sel->can_read ) {
        for my $fh ( @ready ) {
            my $line;
            my $len = sysread $fh, $line, 4096;
            if ( $len == 0 ) {
                $sel->remove( $fh );
                next;
            } else {
                if ( $fh == $rdr ) {
                    $stdout .= $line;
                    print $line if $context->{ io_sync };
                    next;
                }
                if ( $fh == $err ) {
                    $stderr .= $line;
                    warn $line if $context->{ io_sync };
                    next;
                }
            }
        }
    }

    waitpid( $pid, 0 );

    return (( $? >> 8 ), $stdout, $stderr );
}

